var documenterSearchIndex = {"docs":
[{"location":"#AsyncFinalizers.jl","page":"AsyncFinalizers.jl","title":"AsyncFinalizers.jl","text":"","category":"section"},{"location":"","page":"AsyncFinalizers.jl","title":"AsyncFinalizers.jl","text":"AsyncFinalizers\nAsyncFinalizers.register\nAsyncFinalizers.unsafe_unwrap","category":"page"},{"location":"#AsyncFinalizers","page":"AsyncFinalizers.jl","title":"AsyncFinalizers","text":"AsyncFinalizers\n\n(Image: Dev) (Image: CI)\n\nAsyncFinalizers.jl extends finalizer for\n\nAllowing executing arbitrary code, including I/O, upon garbage collection of a given object.\nSafe and unsafe APIs for avoiding escaping and thus \"resurrecting\" the object that would be collected otherwise.\n\nFor more information, see the documentation.\n\nAPI\n\nAsyncFinalizers.register: like finalizer but allows I/O\nAsyncFinalizers.unsafe_unwrap: unwrap the shim wrapper (see below)\n\nExample\n\njulia> using AsyncFinalizers\n\njulia> mutable struct RefInt\n           value::Int\n       end\n\njulia> object = RefInt(42);\n\njulia> AsyncFinalizers.register(object) do shim\n           # Unpack `shim` of the finalized `object`.  I/O is not allowed here.\n           value = shim.value\n           # Return a thunk:\n           return function ()\n               # Arbitrary I/O is possible here:\n               println(\"RefInt(\", value, \") is finalized\")\n           end\n       end;\n\njulia> object = nothing\n\njulia> GC.gc(); sleep(0.1)\nRefInt(42) is finalized\n\nNote that the callback passed to AsyncFinalizers.register receives a shim wrapper and not the original object itself.  To get the original object wrapped in shim, use AsyncFinalizers.unsafe_unwrap.\n\n\n\n\n\n","category":"module"},{"location":"#AsyncFinalizers.register","page":"AsyncFinalizers.jl","title":"AsyncFinalizers.register","text":"AsyncFinalizers.register(finalizer_factory, object)\n\nRegister asynchronous finalizer for an object.\n\nThe callback function finalizer_factory is a function with the following signature\n\nfinalizer_factory(shim) -> async_finalizer\n\ni.e., finalizer_factory is a function that takes shim and returns async_finalizer where shim is an object that wraps the object and provides the same properties and async_finalizer is nothing or a callable that does not take any argument.  The shim is valid only until finalizer_factory returns and not inside async_finalizer.  As such, finalizer_factory must destruct shim and only capture the fields required for async_finalizer.\n\nUse AsyncFinalizers.unsafe_unwrap to unwrap shim and obtain the original object.  However, it is the user's responsibility to ensure that async_finalizer does not capture object.\n\nThe code executed in finalizer_factory should be as minimal as possible.  In particular, no I/O is allowed inside of finalizer_factory.\n\n\n\n\n\n","category":"function"},{"location":"#AsyncFinalizers.unsafe_unwrap","page":"AsyncFinalizers.jl","title":"AsyncFinalizers.unsafe_unwrap","text":"AsyncFinalizers.unsafe_unwrap(shim) -> object\n\nUnwrap a shim and obtain the original object. The user is responsible for ensuring that object does not escape.\n\nSee AsyncFinalizers.register\n\n\n\n\n\n","category":"function"}]
}
